// Set the name of your grammar here (and at the end of this grammar):
    import SymTable.SymTable;
    import java.util.Set;
    import SymTable.Obj;
    import SymTable.Mod;
    import CodeGen.Code;
    import CodeGen.ExpressionResult;
    import AbstractSyntaxTree.*;
    import java.util.ArrayList;
    import java.util.HashMap;

COMPILER SyReC

// Add auxiliary methods and declaration here.



    private boolean IsIdentEql(){
        scanner.ResetPeek();
        return (la.val.equals("$") && scanner.Peek().kind == _ident && scanner.Peek().val.equals("="));
    }

    private boolean NumberTo(){
        scanner.ResetPeek();
        Token next = scanner.Peek();
        if(la.kind == _int) {
            return next.kind == _to;
        }
        if(la.val.equals("#") && next.kind == _ident) {
            next = scanner.Peek();
            return next.kind == _to;
        }
        if(la.val.equals("$") && next.kind == _ident) {
                    next = scanner.Peek();
                    return next.kind == _to;
        }
        if(la.kind == '(') {
            int i = 1;
            while (i > 0) {
                if(next.kind == '(') {
                    i++;
                }
                else if(next.kind == ')'){
                    i--;
                }
                //TODO edge case missing ) Probably check on ';'
                next = scanner.Peek();
            }
            return next.kind == _to;
        }
        return false;
    }

    private boolean IsShift(){
        scanner.ResetPeek();
        Token next = scanner.Peek();
        if(!la.val.equals("(")) {
            return false;
        }
            int i = 1;
            while (i > 0) {
                if(next.val.equals("(")) {
                    i++;
                }
                else if(next.val.equals(")")){
                    i--;
                }
                else if(i == 1 && (next.kind == _shiftL || next.kind == _shiftR)){
                    return true;
                }
                next = scanner.Peek();
            }
            return false;
    }
    private static final Set<String> BinExp = Set.of("+", "-", "^", "*", "/", "%", "*>", "&&", "||", "&", "|", "<", ">", "=", "!=", "<=", ">=");
        boolean IsBinary(){
            scanner.ResetPeek();
            Token next = scanner.Peek();
            if(!la.val.equals("(")) {
                return false;
            }
                int i = 1;
                while (i > 0) {
                    if(next.val.equals("(")) {
                        i++;
                    }
                    else if(next.val.equals(")")){
                        i--;
                    }
                    else if(i == 1 && BinExp.contains(next.val)){
                        return true;
                    }
                    next = scanner.Peek();
                }
                return false;
        }
        SymTable tab = new SymTable();
        Mod curMod;

        private String fileName = null;
        public void setName(String name){
            fileName = name;
        }

        private HashMap<String, CodeMod> finishedModules = new HashMap<>();


        private void Warning (String msg) { //add Warning as function to not need to specify line and col
        		errors.Warning(t.line, t.col, msg);
        	}

        private boolean lineAware = true; //to deactivate line Aware synthesis to save lines
        private boolean costAware = true; //to deactivate cost Aware synthesis to save gates
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.

CHARACTERS
    letter = 'A'..'Z' + 'a'..'z'.
    digit = "0123456789".



TOKENS
    ident   =   ('_'|letter) {'_'|letter|digit}.
    int     =   digit {digit}.
    to      =   "to". //for LookAhead in ForStatement
    shiftR  =   ">>". //for LookAhead  in Expression (shift vs Binary)
    shiftL  =   "<<".



PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)
    activateLine        =   "@lineOn".                  (.lineAware = true;.)
    deactivateLine      =   "@lineOff".                 (.lineAware = false;.)
    activateCost        =   "@costOn".                  (.costAware = true;.)
    deactivateCost      =   "@costOff".                 (.costAware = false;.)

COMMENTS FROM "//" TO "\n"
IGNORE "\r" + "\n" + "\t"


PRODUCTIONS
    number<out NumberExpression number>     =                           (.number = new NumberExpression(0);.)
                                            (int                        (.number = new NumberExpression(Integer.parseInt(t.val));.)
                                            |'#'ident                   (.if(curMod.getLocal(t.val) == null) {
                                                                            SemErr(t.val + "is not defined");
                                                                            number = new NumberExpression(0);
                                                                        }
                                                                        else {
                                                                            number = new NumberExpression(t.val, NumberExpression.Kind.BITWIDTH);
                                                                        }.)
                                            |'$'ident                   (.if(!curMod.loopVarDefined(t.val)) {
                                                                            SemErr(t.val + " is not defined");
                                                                            number = new NumberExpression(0);
                                                                        }
                                                                        else {
                                                                            number = new NumberExpression(t.val, NumberExpression.Kind.LOOPVAR);
                                                                        }.)
                                            |('('number<out NumberExpression firstNumber> ('+'|'-'|'*'|'/')
                                                                                            (.char calcToggle = t.val.charAt(0);.)
                                            number<out NumberExpression secondNumber>       (.switch(calcToggle) {
                                                                                            case '+':
                                                                                                number = new NumberExpression(firstNumber, secondNumber, NumberExpression.Kind.PLUS);
                                                                                                break;
                                                                                            case '-':
                                                                                                number = new NumberExpression(firstNumber, secondNumber, NumberExpression.Kind.MINUS);
                                                                                                break;
                                                                                            case '*':
                                                                                                number = new NumberExpression(firstNumber, secondNumber, NumberExpression.Kind.TIMES);
                                                                                                break;
                                                                                            case '/':
                                                                                                number = new NumberExpression(firstNumber, secondNumber, NumberExpression.Kind.DIVIDE);
                                                                                                break;
                                                                                            default:
                                                                                                number = new NumberExpression(0);
                                                                                                break;
                                                        }.)
                                            ')')).
    //number is a Production and not a Token because it is recursive

    //Program and Modules
    SyReC               =   Module {Module}.

    Module              =   "module" ident                                      (.//add module to SymTable
                                                        if(!tab.addModule(t.val)) {
                                                            SemErr("Module "+t.val+" is already defined");
                                                        }
                                                        curMod = tab.getModule(t.val);
                                                                                .)
                            '(' ParameterList ')' {SignalList}                  (.CodeMod codeModule = Code.createModule(curMod);
                                                                                finishedModules.put(curMod.name, codeModule);
                                                                                ExpressionResult ifExp = new ExpressionResult(1); //generate alwaysTrue if
                                                                                .)
                            StatementList<.out ArrayList<Statement> statements.>               (.//TODO change addStatements to make more sense
                                                                                                codeModule.addStatements(statements);
                                                                                                Code.endModule(fileName, curMod, codeModule);.).
    ParameterList       =   Parameter {',' Parameter}.
    Parameter           =                               (.Obj.Kind kind = null;.)
                            ("in"                       (.kind = Obj.Kind.In;.)
                            |"out"                      (.kind = Obj.Kind.Out;.)
                            |"inout"                    (.kind = Obj.Kind.Inout;.)
                            ) SignalDeclaration<kind>.
    SignalList          =                               (.Obj.Kind kind = null;.)
                            ("wire"                     (.kind = Obj.Kind.Wire;.)
                            |"state"                    (.kind = Obj.Kind.State;.)
                            ) SignalDeclaration<kind> {',' SignalDeclaration<kind>}.


    SignalDeclaration<Obj.Kind kind>   =   ident        (.String ident = t.val;
                                                        int width = 1;.)
                                           {'['int']'}
                                           ['('int      (.width = Integer.parseInt(t.val);.)
                                           ')']
                                           (.curMod.addObj(new Obj(kind, ident, width));.).

    //Statements
    StatementList<.out ArrayList<Statement> statements.>       =   Statement<out Statement first>                  (.statements = new ArrayList<Statement>();
                                                                                                                    statements.add(first);.)
                                                                {';' Statement<out Statement additional>            (.statements.add(additional);.)
                                                                }.

    Statement<out Statement statement>                                                                                                                  (.statement = new SkipStatement(true);.)
                                                = CallStatement<out Statement callStat>                                                                 (.statement = callStat;.)
                                                | ForStatement<out Statement forStat>                                                                   (.statement = forStat;.)
                                                | IfStatement<out Statement ifStat>                                                                     (.statement = ifStat;.)
                                                | UnaryStatement<out Statement unaryStat>                                                               (.statement = unaryStat;.)
                                                | SkipStatement<out Statement skipStat>                                                                 (.statement = skipStat;.)
                                                | Signal<out SignalExpression firstSig> (SwapStatement<out Statement swapStat, firstSig>                (.statement = swapStat;.)
                                                | AssignStatement<out Statement assignStat, firstSig>                                                   (.statement = assignStat;.)
                                                ).
    CallStatement<out Statement call>       =                           (.call = new SkipStatement(true);
                                                                        CallStatement.Kind kind = CallStatement.Kind.CALL;.)
                                            ("call"|"uncall"            (.kind = CallStatement.Kind.UNCALL;.)
                                            ) ident     (.Mod calledMod = tab.getModule(t.val);
                                                        if(calledMod == null) {
                                                            Warning("Module "+t.val+"was not defined before this point");
                                                        }
                                                        .)
                            '(' ident                   (.int parCount = 1;
                                                        ArrayList<String> idents = new ArrayList<>();
                                                        idents.add(t.val);.)
                            {',' ident                  (.parCount++;
                                                        idents.add(t.val);.)
                            } ')'                       (.if(calledMod != null && parCount != calledMod.getSignalCount()) {
                                                            SemErr("Module "+calledMod.name+"needs "+calledMod.getSignalCount()+" signals");
                                                        } else if(calledMod != null) {
                                                            ArrayList<Obj> calledLocals = calledMod.getSignals();
                                                            boolean noError = true;
                                                            for(int i = 0; i < calledLocals.size(); i++) {
                                                                Obj calledLocal = calledLocals.get(i);
                                                                Obj usedLine = curMod.getLocal(idents.get(i));
                                                                if(calledLocal.width != usedLine.width) {
                                                                    SemErr("Original Line "+calledLocal.name+" has a width of "+calledLocal.width+" and usedLine "+usedLine.name+" has a width of "+usedLine.width);
                                                                    noError = false;
                                                                }
                                                            }
                                                            if(noError) {
                                                                ArrayList<Statement> statements = finishedModules.get(calledMod.name).getStatements();
                                                                call = new CallStatement(calledMod,finishedModules.get(curMod.name), curMod, idents, statements, kind, lineAware);
                                                            }
                                                        }
                                                        .)
                            .

    ForStatement<out Statement forStatement>        =                                                                       (.String ident = null;
                                                                                                                            NumberExpression from = new NumberExpression(0);
                                                                                                                            NumberExpression to = new NumberExpression(0);
                                                                                                                            NumberExpression step = new NumberExpression(1);.)
                                                    "for" [IF(IsIdentEql() || NumberTo()) [IF (IsIdentEql())'$' ident       (.ident = t.val;
                                                                                                                            curMod.addLoopVar(ident);.)
                                                     '='] number<out NumberExpression start>                                (.from = start;.)
                                                     "to"] number<out NumberExpression stop>                                (.to = stop;.)
                                                     ["step" ['-'] number<out NumberExpression stepSize>                    (.step = stepSize;.)
                                                     ] StatementList<.out ArrayList<Statement> statements.>                 (.forStatement = new ForStatement(ident, from, to, step, statements, lineAware);
                                                                                                                            curMod.removeLoopVar(ident);.)
                                                     "rof".


    IfStatement<out Statement ifStatement>         =   "if" Expression<out Expression ifExp>
                                                        "then" StatementList<.out ArrayList<Statement> thenStatements.>
                                                        "else" StatementList<.out ArrayList<Statement> elseStatements.>
                                                        "fi" Expression<out Expression fiExp>                                   (.ifStatement = new IfStatement(ifExp, thenStatements, elseStatements, fiExp, lineAware);.)
                                                        .


    AssignStatement<out Statement assign, SignalExpression firstSignal>       =   ('^'|'+'|'-')     (.String assignToggle = t.val;.)
                                                    '=' Expression<out Expression exp>              (.boolean cantAssign = false;
                                                                                                    for(String line : firstSignal.getLines()) {
                                                                                                        if(exp.containsSignal(line)) {
                                                                                                      	    cantAssign = true;
                                                                                                      		break;
                                                                                                        }
                                                                                                    }
                                                                                                    if(cantAssign) {
                                                                                                        SemErr("Signal is contained in the Expression of the assign Statement");
                                                                                                        assign = new SkipStatement(true);
                                                                                                    }
                                                                                                    //TODO check if you can fit smaller numbers into signal
                                                                                                    else if(firstSignal.getWidth() < exp.getWidth()) {
                                                                                                        SemErr("Expression doesnt fit into the Signal Width");
                                                                                                        assign = new SkipStatement(true);
                                                                                                    }
                                                                                                    else {
                                                                                                        AssignStatement.Kind kind;
                                                                                                        switch(assignToggle) {
                                                                                                            case "^":
                                                                                                                kind = AssignStatement.Kind.XOR;
                                                                                                                break;
                                                                                                            case "+":
                                                                                                                kind = AssignStatement.Kind.PLUS;
                                                                                                                break;
                                                                                                            default:
                                                                                                                kind = AssignStatement.Kind.MINUS;
                                                                                                                break;
                                                                                                        }
                                                                                                        assign = new AssignStatement(firstSignal, exp, kind, lineAware);
                                                                                                    }
                                                                                                    .)
                                                    .

    UnaryStatement<out Statement unary>      =   ('~'|"++"|"--")             (.String calcToggle = t.val;.)
                                                '=' Signal<out SignalExpression sig>
                                                        (.UnaryStatement.Kind kind;
                                                        switch(calcToggle) {
                                                            case "~":
                                                                kind = UnaryStatement.Kind.NEGATE;
                                                                break;
                                                            case "++":
                                                                kind = UnaryStatement.Kind.INCREMENT;
                                                                break;
                                                            default:
                                                                kind = UnaryStatement.Kind.DECREMENT;
                                                                break;
                                                        }
                                                        unary = new UnaryStatement(sig, kind, lineAware);.)
                                                .

    SwapStatement<out Statement swap, SignalExpression firstSig>       =   "<=>" Signal<out SignalExpression secondSig>
                                                        (. if(false/*firstSig.getWidth() != secondSig.getWidth()*/ ){
                                                            SemErr("Signal Width is not equal");
                                                            swap =  new SkipStatement(true);
                                                        }
                                                        else {
                                                            swap = new SwapStatement(firstSig, secondSig, lineAware);
                                                        }.).
    SkipStatement<out Statement skip>       =   "skip"      (.skip = new SkipStatement(true);.).
    //TODO, needs to be updated to allow arrays
    Signal<out SignalExpression sig> =   ident              (.String ident = t.val;
                                                            if(!curMod.isDefined(ident)) {
                                                                SemErr("Signal "+ident+" is not defined");
                                                            }
                                                            //TODO error prevention for udnefined signals
                                                            Obj curSignal = curMod.getLocal(ident);
                                                            NumberExpression startWidth = null;
                                                            NumberExpression endWidth = null;
                                                            .)
                            {'[' Expression<out Expression exp> ']'}
                            ['.' number<out NumberExpression lowerBound> (.startWidth = lowerBound;
                                                                        endWidth = lowerBound; //so far both are equal
                                                                        .)
                            [':' number<out NumberExpression upperBound>  (.endWidth = upperBound;.)
                            ]]                                          (.if(startWidth == null) {
                                                                            startWidth = new NumberExpression(0);
                                                                            endWidth = new NumberExpression(curSignal.width -1);
                                                            }
                                                            sig = new SignalExpression (curSignal, startWidth, endWidth);
                                                            .)
                            .

    //Expressions
    Expression<out Expression exp>                                                      (.exp = new NumberExpression(0);.)
                        = Signal<out SignalExpression sig>                              (.exp = sig;.)
                        | IF (IsShift()) ShiftExpression<out Expression shiftExp>       (.exp = shiftExp;.)
                        | IF (IsBinary())BinaryExpression<out Expression binExp>        (.exp = binExp;.)
                        | UnaryExpression<out Expression unExp>                         (.exp = unExp;.)
                        | number<out Expression numExp>                                 (.exp = numExp;.)
                        .


    BinaryExpression<out Expression binExp> =   '(' Expression<out Expression firstExp>
                                                  ('+'|'-'|'^'|'*'|'/'|'%'|"*>"|"&&"|"||"|'&'|'|'|'<'|'>'|'='|"!="|"<="|">=")           (.String operation = t.val;.)
                                                  Expression<out Expression secondExp> ')'                                              (.BinaryExpression.Kind kind = BinaryExpression.Kind.PLUS;
                                                                                                                                        switch(operation) {
                                                                                                                                          case "+":
                                                                                                                                            kind = BinaryExpression.Kind.PLUS;
                                                                                                                                            break;
                                                                                                                                          case "-":
                                                                                                                                            kind = BinaryExpression.Kind.MINUS;
                                                                                                                                            break;
                                                                                                                                          case "^":
                                                                                                                                            kind = BinaryExpression.Kind.BIT_XOR;
                                                                                                                                            break;
                                                                                                                                          case "*":
                                                                                                                                            kind = BinaryExpression.Kind.TIMES_UPPER;
                                                                                                                                            break;
                                                                                                                                          case "/":
                                                                                                                                            kind = BinaryExpression.Kind.DIVIDE;
                                                                                                                                            break;
                                                                                                                                          case "%":
                                                                                                                                            kind = BinaryExpression.Kind.REMAINDER;
                                                                                                                                            break;
                                                                                                                                          case "*>":
                                                                                                                                            kind = BinaryExpression.Kind.TIMES_LOWER;
                                                                                                                                            break;
                                                                                                                                          case "&&":
                                                                                                                                            kind = BinaryExpression.Kind.LOG_AND;
                                                                                                                                            break;
                                                                                                                                          case "||":
                                                                                                                                            kind = BinaryExpression.Kind.LOG_OR;
                                                                                                                                            break;
                                                                                                                                          case "&":
                                                                                                                                            kind = BinaryExpression.Kind.BIT_AND;
                                                                                                                                            break;
                                                                                                                                          case "|":
                                                                                                                                            kind = BinaryExpression.Kind.BIT_OR;
                                                                                                                                            break;
                                                                                                                                          case "<":
                                                                                                                                            kind = BinaryExpression.Kind.LESSER;
                                                                                                                                            break;
                                                                                                                                          case ">":
                                                                                                                                            kind = BinaryExpression.Kind.GREATER;
                                                                                                                                            break;
                                                                                                                                          case "=":
                                                                                                                                            kind = BinaryExpression.Kind.EQL;
                                                                                                                                            break;
                                                                                                                                          case "!=":
                                                                                                                                            kind = BinaryExpression.Kind.NEQL;
                                                                                                                                            break;
                                                                                                                                          case "<)":
                                                                                                                                            kind = BinaryExpression.Kind.LEQL;
                                                                                                                                            break;
                                                                                                                                          case ">=":
                                                                                                                                            kind = BinaryExpression.Kind.GEQL;
                                                                                                                                            break;
                                                                                                                                        }
                                                                                                                                        binExp = new BinaryExpression(firstExp, secondExp, kind);
                                                                                                                                        .)
                                                    .


    UnaryExpression<out Expression unExp>     =                                        (.UnaryExpression.Kind kind = UnaryExpression.Kind.LOGICAL;.)
                                                    ('!'|'~'                                (.kind = UnaryExpression.Kind.BITWISE;.)
                                                    ) Expression<out Expression exp>        (.if(kind == UnaryExpression.Kind.LOGICAL) {
                                                                                                if(exp.getWidth() != 1) {
                                                                                                //TODO width of BITWIDTH cant be dynamically checked during parse
                                                                                                    SemErr("Logical Not on a Busline or an Expression that is not a boolean");
                                                                                                    unExp = new NumberExpression(0);
                                                                                                }
                                                                                                else {
                                                                                                    unExp = new UnaryExpression(exp, kind);
                                                                                                }
                                                                                            }
                                                                                            else {
                                                                                                unExp = new UnaryExpression(exp, kind);
                                                                                            }.)
                                                    .


    ShiftExpression<out Expression shiftExp>  =   '(' Expression<out Expression exp>           (.ShiftExpression.Kind kind = ShiftExpression.Kind.RIGHT;.)
                                                  (shiftL                                           (.kind = ShiftExpression.Kind.LEFT;.)
                                                  |shiftR
                                                  ) number<out NumberExpression number>             (.shiftExp = new ShiftExpression(exp, number, kind);.)')'.




// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END SyReC.